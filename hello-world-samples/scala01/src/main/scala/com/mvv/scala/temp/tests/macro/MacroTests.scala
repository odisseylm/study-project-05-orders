package com.mvv.scala.temp.tests.`macro`

import scala.quoted.Expr

class Type1

// It should be generated by macro
given givenCanEqual_Type1_Null: CanEqual[Type1, Null] = CanEqual.derived
given givenCanEqual_Type1Null_Null: CanEqual[Type1|Null, Null] = CanEqual.derived
given givenCanEqual_Type1Null_Type1: CanEqual[Type1|Null, Type1] = CanEqual.derived
given givenCanEqual_Null_Type1: CanEqual[Null, Type1] = CanEqual.derived
given givenCanEqual_Null_Type1Null: CanEqual[Null, Type1|Null] = CanEqual.derived
given givenCanEqual_Type1_Type1Null: CanEqual[Type1, Type1|Null] = CanEqual.derived



//noinspection ScalaUnusedSymbol
def testNullsEqualityMacro_testCompilation(): Unit = {

  val t1: Type1 = Type1()
  val t2: Type1|Null = Type1()

  if (t1 == null) println("1")
  if (t2 == null) println("1")

  if (null == t1) println("1")
  if (null == t2) println("1")

  //noinspection DfaConstantConditions
  if (t1 == t1) println("1")
  if (t1 == t2) println("1")

  if (t2 == t1) println("1")
  //noinspection DfaConstantConditions
  if (t2 == t2) println("1")
}


//noinspection ScalaUnusedSymbol
def aaa(): Unit = {
  val v1 =  test(false, scala.util.Random().nextInt() == 345)
  //newCode234()

  //println(printHello.show) // print("Hello")

//  import scala.quoted.* // imports Quotes, Expr
//  val msg = Expr("Hello")
//  val printHello = '{ print($msg) }
//  println(printHello.show) // print("Hello")

  // injecting some generated code (see generateLocalCode1 impl)
  generateLocalCode1("Vovan")

  // injecting just this code (local code)
  inspect {
    val v22 = scala.util.Random().nextInt()
    val v23 = v22 == 567
    println(s"v22 [$v22] == 567 => $v23")
  }

  assert22("1" == "2")
}

// compilation error
//generateLocalCode1("Global Vovan")
